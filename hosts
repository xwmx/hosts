#!/usr/bin/env bash

# Strict Mode
set -o nounset
set -o errexit
set -o pipefail
IFS=$'\n\t'

# Current version (semver)
_VERSION="1.0.0"

# Command to run by default
HOSTS_DEFAULT_COMMAND="${HOSTS_DEFAULT_COMMAND:-get}"

# Path to the host file
HOSTS_PATH="${HOSTS_PATH:-/etc/hosts}"

# _die()
#
# Usage:
#   _die "Error message"
#
# Print a message and dies
function _die() {
    echo "$1" 1>&2
    exit 1
}

# Options

# Contains the arguments that are not
_COMMAND_ARGV=("${0}")
_CMD=""
_AUTO_SUDO=1

while [[ ${#} -gt 0 ]]; do
    __opt="${1}"

    shift

    case "${__opt}" in
    -h | --help)
        _CMD="help"
        ;;
    --version)
        _CMD="version"
        ;;
    --no-sudo)
        _AUTO_SUDO=0
        ;;
    *)
        # The first non-option argument is assumed to be the command name.
        # All subsequent arguments are added to $_COMMAND_ARGV.
        if [[ -n "${_CMD:-}" ]]; then
            _COMMAND_ARGV+=("${__opt}")
        else
            _CMD="${__opt}"
        fi
        ;;
    esac
done

function _search_in_file() {
    local arguments=("$@")

    if [ ${#arguments[@]} -ne 2 ]; then
        _die "_search_in_file requires 2 parameters"
    fi

    local pattern=${arguments[0]}
    local file=${arguments[1]}

    sed -n -e "s/\\($pattern\\)/\\1/p" "$file"
}

function _replace_in_file() {
     local arguments=("$@")

    if [ ${#arguments[@]} -ne 3 ]; then
        _die "_search_in_file requires 3 paramesters"
    fi

    local pattern=${arguments[0]}
    local replacement_pattern=${arguments[1]}
    local file=${arguments[2]}

    sed -i -e "s/$pattern/${replacement_pattern}/" "$file"
}

# _COMMAND_ARGV minus the first parameter
_COMMAND_PARAMETERS=(${_COMMAND_ARGV[*]})
unset "_COMMAND_PARAMETERS[0]"

# Program base name
_ME=$(basename "${0}")

# Load Commands
_DEFINED_COMMANDS=()

# _load_commands()
#
# Usage:
#   _load_commands
#
# Loads all of the commands sourced in the environment.
function _load_commands() {
    local _function_list
    mapfile -t _function_list < <(declare -F)

    for __name in "${_function_list[@]}"; do
        local _function_name
        _function_name=$(printf "%s" "${__name}" | awk '{ print $3 }')

        if [[ "${_function_name}" =~ ^cmd_(.*) ]]; then
            _DEFINED_COMMANDS+=("${_function_name#"cmd_"}")
        fi
    done
}

# Entrypoint
function _main() {
    if [[ -z "${_CMD}" ]]; then
        _CMD="${HOSTS_DEFAULT_COMMAND}"
    fi

    _load_commands

    if _contains "${_CMD}" "${_DEFINED_COMMANDS[*]:-}"; then
        cmd_${_CMD} "${_COMMAND_PARAMETERS[@]:-}"
    else
        _die "Unknown command: ${_CMD}"
    fi
}

# _contains()
#
# Usage:
#   _contains "$item" "${list[*]}"
function _contains() {
    local _test_list=(${*:2})

    for __test_element in "${_test_list[@]:-}"; do
        if [[ "${__test_element}" == "${1}" ]]; then
            return 0
        fi
    done

    return 1
}

# _verify_write_permissions
function _verify_write_permissions() {
    if ! test -w "${HOSTS_PATH}"; then
        if ((_AUTO_SUDO)); then
            sudo "${_ME}" "${_CMD}" "${_COMMAND_PARAMETERS[@]:-}"
            exit $?
        else
            _die "You don't have permission to perform this operation."
        fi
    fi
}

function _is_valid_ip() {
    if [[ "$1" =~ ^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$ ]]; then
        return 0
    elif [[ "$1" =~ ^((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?$ ]]; then
        return 0
    fi

    return 1
}

function _is_valid_domain() {
    if [[ "$1" = *[[:space:]]* ]]; then
        return 1
    fi

    return 0
}

function _is_valid_group() {
    if [[ "$1" = *[[:space:]]* ]]; then
        return 1
    fi

    return 0
}

function _get_group() {
    local group_name="${1:-}"

    if [[ -z "${group_name}" ]]; then 
        _die "Group name parameter is required"
    elif ! _is_valid_group "${group_name}"; then
        _die "Group name parameter is not valid"
    fi

    local group_string
    
    mapfile -t group_string < <(sed -n "s/\\#group:${group_name}[[:space:]]\+\\(.*\\)$/\\1/p" "${HOSTS_PATH}")

    if [[ ${#group_string[@]} -gt 1 ]]; then
        _die "Group is duplicated in file ${HOSTS_PATH}"
    elif [[ ${#group_string[@]} -eq 0 ]]; then
        echo ""
    else
        echo "${group_string[0]}"
    fi
}

function _set_group() {
    local group_name="${1:-}"

    if [[ -z "${group_name}" ]]; then 
        _die "Group name parameter is required"
    elif ! _is_valid_group "${group_name}"; then
        _die "Group name parameter is not valid"
    fi

    local existing_group
    local group="#group:${group_name}"

    for domain in "${@:2}"; do
        group="${group} ${domain}"
    done
    
    mapfile -t existing_group < <(sed -n "s/\\#group:${group_name}[[:space:]]\+\\(.*\\)$/\\1/p" "${HOSTS_PATH}")

    if [[ ${#existing_group[@]} -gt 1 ]]; then
        _die "Group is duplicated in file ${HOSTS_PATH}"
    elif [[ ${#existing_group[@]} -eq 0 ]]; then
        sed -i "1 s/^/${group}\n/" "${HOSTS_PATH}"
    else
        _replace_in_file "^#group:${group_name}[[:space:]]\+.*$" "${group}" "${HOSTS_PATH}"
    fi
}

function _delete_from_file() {
    local pattern="${1:-}"
    local file="${2:-}"

    if [[ -z "${pattern}" ]]; then
        _die "Pattern is required"
    elif ! test -w "${file}"; then
        _die "${file} is not writeable"
    fi

    sed -i -e "/${pattern}/d" "${file}"
}

function _file_contains() {
    local pattern="${1:-}"
    local file="${2:-}"

    if [[ -z "${pattern}" ]]; then
        _die "Pattern is required"
    elif ! test -r "${file}"; then
        _die "${file} is not readable"
    fi

    if ! grep -e "${pattern}" "${file}"; then
        return 1
    else
        return 0
    fi
}

function _is_host_set() {
    local hostname="${1:-}"

    if ! _file_contains "^[^[:space:]#]\+[[:space:]]\+${hostname}\([[:space:]]\+\|$\)" "${HOSTS_PATH}"; then
        return 1
    else
        return 0
    fi
}

function _delete_host_entry() {
    local hostname="${1:-}"

    _delete_from_file "^[^[:space:]#]\+[[:space:]]\+${hostname}\([[:space:]]\+\|$\)" "${HOSTS_PATH}"
}

function _set_host_entry() {
    local _ip="${1:-}"
    local _hostname="${2:-}"

    if [[ -z "${_ip:-}" ]]; then
        _die "IP parameter is missing."
    elif [[ -z "${_hostname:-}" ]]; then
        _die "Hostname parameter is missing."
    elif ! _is_valid_ip "${_ip}"; then
        _die "${_ip} is not a valid ip address."
    elif ! _is_valid_domain "${_hostname}"; then
        _die "${_hostname} is not a valid hostname."
    elif grep -q -e "^[^[:space:]#]\+[[:space:]]\+${_hostname}\([[:space:]]\+.*\)\?$" "${HOSTS_PATH}"; then
        _replace_in_file "^[^[:space:]#]\+[[:space:]]\+${_hostname}\([[:space:]]\+.*\)\?$" "${_ip}\t${_hostname}" "${HOSTS_PATH}"
    else
        printf "%s\t%s\n" "${_ip}" "${_hostname}" >> "${HOSTS_PATH}"
    fi
}

function _get_host_entry() {
    local hostname="${1:-}"

    if [[ -z "${hostname:-}" ]]; then
        _die "Hostname parameter is missing."
    elif ! _is_valid_domain "${hostname}"; then
        _die "${hostname} is not a valid hostname."
    fi

    sed -n -e "s/^\([^[:space:]#]\+\)[[:space:]]\+${hostname}\([[:space:]]\+\|$\)/\\1/p" "${HOSTS_PATH}"
}

declare -A __desc
# desc()
#
# Usage:
#   desc <name> <description>
#   desc --get <name>
#
# Options:
#   --get  Print the description for <name> if one has been set.
function _desc() {
    [[ -z "${1:-}" ]] && _die "_desc(): No command name specified."

    if [[ "${1}" == "--get" ]]; then
        [[ -z "${2:-}" ]] && _die "_desc(): No command name specified."

        local _name="${2:-}"
        local _desc_var="__desc[${_name}]"

        if [[ -n "${!_desc_var:-}" ]]; then
            printf "%s\\n" "${!_desc_var}"
        else
            printf "No additional information for \`%s\`\\n" "${_name}"
        fi
    else
        if [[ -n "${2:-}" ]]; then # argument is present
            read -r -d '' "__desc[${1}]" <<HEREDOC
${2}
HEREDOC

        else # no argument is present, so assume piped input
            read -r -d '' "__desc[${1}]" || true
        fi
    fi
}

# Version #####################################################################

_desc "version" <<HEREDOC
Usage:
  ${_ME} (version | --version)

Description:
  Display the current program version.

  To save you the trouble, the current version is ${_VERSION}
HEREDOC
function cmd_version() {
    printf "%s\\n" "${_VERSION}"
}

# Help ########################################################################

_desc "help" <<HEREDOC
Usage:
  ${_ME} help [<command>]

Description:
  Display help information for ${_ME} or a specified command.
HEREDOC

function cmd_help() {
    if [[ -n "${1:-}" ]]; then
        _desc --get "${1}"
    else
        cat <<HEREDOC
Usage:
  ${_ME} set <hostname> <ip address>
  ${_ME} rm <hostname>
  ${_ME} group <group> set <hostname 1> <hostname 2> ... <hostname n>
  ${_ME} group <group> + <hostname 1> <hostname 2> ... <hostname n>
  ${_ME} group <group> - <hostname 1> <hostname 2> ... <hostname n>
  ${_ME} group <group> rm
  ${_ME} group <group> <ip address>
  ${_ME} group <group> reset
  ${_ME} group <group>

Options:
  --no-sudo    Do not run commands with \`sudo\` automatically.
  -h --help    Display this help information.
  --version    Display version information.

Help:
  ${_ME} help [<command>]
HEREDOC
    fi
}

# ------------------------------------------------------------------------- add

function cmd_get() {
     local _hostname="${1:-}"

     _get_host_entry "${_hostname}"
}

_desc "set" <<HEREDOC
Usage:
  ${_ME} set <hostname> <ip address>

Description:
  Set an hostfile entry
HEREDOC

function cmd_set() {
    _verify_write_permissions "$@"

    local _hostname="${1:-}"
    local _ip="${2:-}"

    _set_host_entry "${_ip}" "${_hostname}"

    printf "Set entry %s to %s\n" "${_hostname}" "${_ip}"
}

_desc "rm" <<HEREDOC
Usage:
  ${_ME} rm <hostname>

Description:
  Remove an entry
HEREDOC

function cmd_rm() {
    _verify_write_permissions "$@"

    local _hostname="${1:-}"

    if [[ -z "${_hostname:-}" ]]; then
        _die "Hostname parameter is missing."
    elif ! _is_valid_domain "${_hostname}"; then
        _die "${_hostname} is not a valid hostname."
    elif ! _is_host_set "${_hostname}"; then
        _die "Hostname not found."
    fi

    _delete_host_entry "${_hostname}"
    printf "Removed entry %s\n" "${_hostname}"
}

_desc "group" <<HEREDOC
Usage:
  ${_ME} group <group> set <hostname 1> <hostname 2> ... <hostname n>
  ${_ME} group <group> + <hostname 1> <hostname 2> ... <hostname n>
  ${_ME} group <group> - <hostname 1> <hostname 2> ... <hostname n>
  ${_ME} group <group> rm
  ${_ME} group <group> <ip address>
  ${_ME} group <group> reset
  ${_ME} group <group>

Description:
  no parameter: show the content of a group
  set: create a new group or change an existing one
  +: add entries to an existing group
  -: remove entries from an existing group
  rm: delete an group
  <ip address>: set all the entries of an existing group to the ip address
  reset: remove all entries matching the group content
HEREDOC

function cmd_group() {
	local group_name="${1:-}"
	local action="${2:-}"

	if [[ -z "${group_name}" ]]; then
        _die "Group name is required."
    elif ! _is_valid_group "${group_name}"; then
        _die "${group_name} is not a valid group name."
    elif [[ -z "${action}" ]]; then
		_group_get "${group_name}"
		return 0
    fi

    _verify_write_permissions "$@"

	case "$2" in
		+)
			_group_add "${group_name}" ${@:3}
			;;
		-)
			_group_rm "${group_name}" ${@:3}
			;;
		set)
			_group_set "${group_name}" ${@:3}
			;;
		rm)
			_group_del "${group_name}"
			;;
		reset)
			_group_reset "${group_name}"
			;;
		*)
			_group_set_ip "${group_name}" "${action}"
			;;
    esac
	
}

function _group_get() {
	local group_name="${1:-}"
	local group

    IFS=" "
    read -r -a group <<< "$(_get_group "${group_name}")"

	if [[ ${#group[@]} -eq 0 ]]; then
		_die "${group_name} doesn't exists or is empty"
	fi

	for domain in "${group[@]}"; do
        local address
        address=$(_get_host_entry "${domain}")
        if [[ -z "${address:-}" ]]; then
		    printf "%s\n" "${domain}"
        else
            printf "%s\t%s\n" "${domain}" "${address}"
        fi
	done
}

function _group_add() {
    local group_name="${1:-}"
	local group

    IFS=" "
    read -r -a group <<< "$(_get_group "${group_name}")"

	for domain in "${@:2}"; do
		if ! _contains "${domain}" "${group[*]}"; then
			group+=("${domain}")
		fi
	done

    _set_group "${group_name}" "${group[*]}"

	printf "Group %s modified.\n" "${group_name}"
}

function _group_rm() {
    local group_name="${1:-}"
	local group
	local new_group

    IFS=" "
    read -r -a group <<< "$(_get_group "${group_name}")"

	for domain in "${group[@]}"; do
		if ! _contains "${domain}" "${@:2}"; then
			new_group+=("${domain}")
		fi
	done

    _set_group "${group_name}" "${new_group[*]}"

	printf "Group %s modified.\n" "${group_name}"
}

function _group_set() {
    local group_name="${1:-}"
    _set_group "${group_name}" "${@:2}"

	printf "Group %s created.\n" "${group_name}"
}

function _group_del() {
    _verify_write_permissions "$@"

    local group_name="${1:-}"

    if [[ -z "${group_name}" ]]; then
        _die "Group name is required."
    elif ! _is_valid_group "${group_name}"; then
        _die "Group name parameter is not valid."
    fi

    local current_group
    IFS=" "
    read -r -a current_group <<< "$(_get_group "${group_name}")"

    if [[ ${#current_group[@]} -eq 0 ]]; then
        _die "Group ${group_name} not found."
    fi

    for domain in "${current_group[@]}"; do
        _delete_host_entry "${domain}"
    done

    _delete_from_file "^#group:${group_name}[[:space:]]\+.*$" "${HOSTS_PATH}"

    printf "Group %s deleted.\n" "${group_name}"
}


function _group_set_ip() {
    _verify_write_permissions "$@"

    local group_name="${1:-}"
    local ip="${2:-}"

    if [[ -z "${group_name}" ]]; then
        _die "Group name is required."
    elif ! _is_valid_group "${group_name}"; then
        _die "Group name parameter is not valid."
    elif [[ -z "${ip}" ]]; then
        _die "IP parameter is required."
    elif ! _is_valid_ip "${ip}"; then
        _die "${ip} is not a valid IP address."
    fi

    local current_group
    IFS=" "
    read -r -a current_group <<< "$(_get_group "${group_name}")"

    if [[ ${#current_group[@]} -eq 0 ]]; then
        _die "Group ${group_name} not found."
    fi

    for domain in "${current_group[@]}"; do
        _set_host_entry "${ip}" "${domain}"

        printf "%s set to %s\n" "${domain}" "${ip}"
    done
}

function _group_reset() {
    _verify_write_permissions "$@"

    local group_name="${1:-}"

    if [[ -z "${group_name}" ]]; then
        _die "Group name is required."
    elif ! _is_valid_group "${group_name}"; then
        _die "Group name parameter is not valid."
    fi

    local current_group
    IFS=" "
    read -r -a current_group <<< "$(_get_group "${group_name}")"

    if [[ ${#current_group[@]} -eq 0 ]]; then
        _die "Group ${group_name} not found."
    fi

    for domain in "${current_group[@]}"; do
        _delete_host_entry "${domain}"

        printf "Entry %s removed\n" "${domain}"
    done
}

# Run Program
_main
